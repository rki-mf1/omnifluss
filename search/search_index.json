{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Omnifluss rki-mf1/omnifluss is a bioinformatics pipeline for the reconstruction of virus genomes. The word \"omnifluss\" is a neologism of the prefix omni ([\u02c8\u0254mni] - from Latin all or whole ) and the word Fluss ([fl\u028as] - from German flow or flux ). Omnifluss takes raw sequencing data and performs operations such as quality filtering, primer clipping, taxanomic classification, alignment, variant calling, consensus assembly, and optionally reference selection. The specific algorithms and software selected for these operations primarily depend on two parameters: virus type and sequencing technology. Beside these two parameters many settings and subroutines can be finetuned. After a successful run omnifluss returns a consensus sequence, intermediate files, and an HTML report that includes statistics of the individual operations. Technical prerequisites For system requirements of omnifluss please see the Prerequisites page. Analyse your data For in depth guidance of how to use omnifluss with your data please see the individual virus pages. Last update: October, 20th 2025","title":"Home"},{"location":"#omnifluss","text":"rki-mf1/omnifluss is a bioinformatics pipeline for the reconstruction of virus genomes. The word \"omnifluss\" is a neologism of the prefix omni ([\u02c8\u0254mni] - from Latin all or whole ) and the word Fluss ([fl\u028as] - from German flow or flux ). Omnifluss takes raw sequencing data and performs operations such as quality filtering, primer clipping, taxanomic classification, alignment, variant calling, consensus assembly, and optionally reference selection. The specific algorithms and software selected for these operations primarily depend on two parameters: virus type and sequencing technology. Beside these two parameters many settings and subroutines can be finetuned. After a successful run omnifluss returns a consensus sequence, intermediate files, and an HTML report that includes statistics of the individual operations.","title":"Omnifluss"},{"location":"#technical-prerequisites","text":"For system requirements of omnifluss please see the Prerequisites page.","title":"Technical prerequisites"},{"location":"#analyse-your-data","text":"For in depth guidance of how to use omnifluss with your data please see the individual virus pages. Last update: October, 20th 2025","title":"Analyse your data"},{"location":"contributions/","text":"Contributions Omnifluss' lead developer team is the rki-mf1 (Genome Competence Center), in particular: M Lataretu T Krannich D Ternovoj Issues and feature requests To file an issue with omnifluss, discuss usage, and/or request a new software feature please address your inquiry to the Github repository's Issue section .","title":"Contributions"},{"location":"contributions/#contributions","text":"Omnifluss' lead developer team is the rki-mf1 (Genome Competence Center), in particular: M Lataretu T Krannich D Ternovoj","title":"Contributions"},{"location":"contributions/#issues-and-feature-requests","text":"To file an issue with omnifluss, discuss usage, and/or request a new software feature please address your inquiry to the Github repository's Issue section .","title":"Issues and feature requests"},{"location":"prerequisites/","text":"Prerequisites Omnifluss is developed and launched using the Nextflow workflow language and intended for Unix operating systems. User requirements We successfully tested the following work environments and operating systems to launch omnifluss: Operating system: Ubuntu Linux 24.04.02 LTS; 22.04.05 LTS Package manager/ container engine : conda, singularity or docker. We strongly recommend the container engines (singularity or docker) for stability. Work environment: nextflow 25.04.3 These requirements suffice for running omnifluss on your data. You can install Nextflow via its official installation instructions or simply via conda : conda create -n omnifluss -c bioconda -c conda-forge nextflow==25.04.3 Note: With Nextflow in your active working environment you don't need to install omnifluss at all! In the standard use case, Nextflow will automatically clone and use the omnifluss source code from its Github repository. Developer requirements Operating system: Ubuntu Linux 24.04.02 LTS, 22.04.05 LTS Package manager/ container engine : conda, singularity or docker. We strongly recommend the container engines (singularity or docker) for stability. Work environment: nextflow 25.04.3, nf-core 3.3.1, nf-test 0.9.2 These requirements are only for developers and people intending to contribute to omnifluss. You can recreate our developers' work environment via conda conda : conda create -n omnifluss -c bioconda -c conda-forge \\ nextflow==25.04.3 \\ nf-core==3.3.1 \\ nf-test==0.9.2","title":"Prerequisites"},{"location":"prerequisites/#prerequisites","text":"Omnifluss is developed and launched using the Nextflow workflow language and intended for Unix operating systems.","title":"Prerequisites"},{"location":"prerequisites/#user-requirements","text":"We successfully tested the following work environments and operating systems to launch omnifluss: Operating system: Ubuntu Linux 24.04.02 LTS; 22.04.05 LTS Package manager/ container engine : conda, singularity or docker. We strongly recommend the container engines (singularity or docker) for stability. Work environment: nextflow 25.04.3 These requirements suffice for running omnifluss on your data. You can install Nextflow via its official installation instructions or simply via conda : conda create -n omnifluss -c bioconda -c conda-forge nextflow==25.04.3 Note: With Nextflow in your active working environment you don't need to install omnifluss at all! In the standard use case, Nextflow will automatically clone and use the omnifluss source code from its Github repository.","title":"User requirements"},{"location":"prerequisites/#developer-requirements","text":"Operating system: Ubuntu Linux 24.04.02 LTS, 22.04.05 LTS Package manager/ container engine : conda, singularity or docker. We strongly recommend the container engines (singularity or docker) for stability. Work environment: nextflow 25.04.3, nf-core 3.3.1, nf-test 0.9.2 These requirements are only for developers and people intending to contribute to omnifluss. You can recreate our developers' work environment via conda conda : conda create -n omnifluss -c bioconda -c conda-forge \\ nextflow==25.04.3 \\ nf-core==3.3.1 \\ nf-test==0.9.2","title":"Developer requirements"},{"location":"adr/001_INV_referenceIndexing/","text":"Title Design decision about when to perform reference indexing at INV GR. Context The INV GR workflow requires a KMA index to be present at time of invocation of the reference selection. Decision Present, the check for existence and creation of the KMA index is excluded from the reference selection subworkflow. Generating the KMA index will be subject to another separate subworkflow. Status [ ] proposed [x] accepted [ ] deprecated [ ] superseded (via ADR#) Consequences Pro: avoids race condition during the reference selection for each sample Con: Might violates the the nf-core standard (format recommendation) in case the subworkflow will only contain one process, i.e. the indexing","title":"001 INV referenceIndexing"},{"location":"adr/001_INV_referenceIndexing/#title","text":"Design decision about when to perform reference indexing at INV GR.","title":"Title"},{"location":"adr/001_INV_referenceIndexing/#context","text":"The INV GR workflow requires a KMA index to be present at time of invocation of the reference selection.","title":"Context"},{"location":"adr/001_INV_referenceIndexing/#decision","text":"Present, the check for existence and creation of the KMA index is excluded from the reference selection subworkflow. Generating the KMA index will be subject to another separate subworkflow.","title":"Decision"},{"location":"adr/001_INV_referenceIndexing/#status","text":"[ ] proposed [x] accepted [ ] deprecated [ ] superseded (via ADR#)","title":"Status"},{"location":"adr/001_INV_referenceIndexing/#consequences","text":"Pro: avoids race condition during the reference selection for each sample Con: Might violates the the nf-core standard (format recommendation) in case the subworkflow will only contain one process, i.e. the indexing","title":"Consequences"},{"location":"adr/002_INV_referenceSelectionNextflowChannels/","text":"Title Design decisions about how to organize and pass information via Nextflow channels during the reference selection. Context The INV GR workflow currently has two modes of reference selection, static and auto . However, in each mode the input to the workflow is given in a different format, a single FASTA file or a database of FASTA files, respectively. Both modes must yield a channel of FASTA sequences for downstream steps of the main workflow. In case of auto mode index files might be present or absent. Required is a Nextflow channel design with functional seperation such that, ideally, a minimal number of channels are passed and no channels need to be joint, split or reordered as part of the main workflow. Decision The static mode uses the single FASTA file to construct the final reference channel (ch_fasta_references) which is not subject to further selection steps. The auto mode uses one or multiple FASTA files, here called database , to construct a reference channel which is subsequently processed by the reference selection subworkflows. Before the reference selection in auto mode, a set of index files is created corresponding to each FASTA in the database if not present. The index files for all FASTA files in the database are stored in a separate channel (ch_kma_index). Status [ ] proposed [ ] accepted [ ] deprecated [x] superseded (via ADR#003) Consequences Pro: properly labeled and streamlined Nextlow channels mode selection can be taken to the main workflow s.t. we avoid using and logging reference selection subworkflows in static mode Con: one more channel to pass between subworkflows in auto mode compared to a joint channel of FASTA files plus their corresponding indexes creation of ch_fasta_references brings sightly more code to the main workflow igsmp.nf","title":"002 INV referenceSelectionNextflowChannels"},{"location":"adr/002_INV_referenceSelectionNextflowChannels/#title","text":"Design decisions about how to organize and pass information via Nextflow channels during the reference selection.","title":"Title"},{"location":"adr/002_INV_referenceSelectionNextflowChannels/#context","text":"The INV GR workflow currently has two modes of reference selection, static and auto . However, in each mode the input to the workflow is given in a different format, a single FASTA file or a database of FASTA files, respectively. Both modes must yield a channel of FASTA sequences for downstream steps of the main workflow. In case of auto mode index files might be present or absent. Required is a Nextflow channel design with functional seperation such that, ideally, a minimal number of channels are passed and no channels need to be joint, split or reordered as part of the main workflow.","title":"Context"},{"location":"adr/002_INV_referenceSelectionNextflowChannels/#decision","text":"The static mode uses the single FASTA file to construct the final reference channel (ch_fasta_references) which is not subject to further selection steps. The auto mode uses one or multiple FASTA files, here called database , to construct a reference channel which is subsequently processed by the reference selection subworkflows. Before the reference selection in auto mode, a set of index files is created corresponding to each FASTA in the database if not present. The index files for all FASTA files in the database are stored in a separate channel (ch_kma_index).","title":"Decision"},{"location":"adr/002_INV_referenceSelectionNextflowChannels/#status","text":"[ ] proposed [ ] accepted [ ] deprecated [x] superseded (via ADR#003)","title":"Status"},{"location":"adr/002_INV_referenceSelectionNextflowChannels/#consequences","text":"Pro: properly labeled and streamlined Nextlow channels mode selection can be taken to the main workflow s.t. we avoid using and logging reference selection subworkflows in static mode Con: one more channel to pass between subworkflows in auto mode compared to a joint channel of FASTA files plus their corresponding indexes creation of ch_fasta_references brings sightly more code to the main workflow igsmp.nf","title":"Consequences"},{"location":"adr/003_INV_referenceSelectionNextflowChannels/","text":"Title Design decisions about the reference selection and how to load, organize, and pass reference sequences via Nextflow channels. Context The Influenza workflow currently has two modes of providing reference genome segments via --reference selection , static and kma . For downstream processes of the workflow, both modes must eventually create and pass a channel of one final FASTA file of genome segments. Problem. Each mode of the --reference_selection accepts a different input format: with static the workflow takes a single FASTA file (with one sequence per segment) and with kma the workflow takes a directory of multiple FASTA files (one file per segment containing one or more sequences) and their KMA index files, together called database . These input formats require a Nextflow channel design where, ideally, a minimal number of channels are passed downstream and no channels need to be joint, split or reordered as part of the main workflow. Decision We maintain a single global Nextflow channel ch_final_topRefs for the purpose of reference selection. The static mode simply passes a single FASTA file to ch_final_topRefs which is not subject to further selection steps. The kma mode uses the database to load its FASTA files and index files into two separate temporary channels. These two channels are passed to the reference selection subworkflow FASTA_REFERENCE_SELECTION_ALL . The reference selection subworkflow returns a single FASTA file of one sequence per segment. This file is then stored in the ch_final_topRefs channel and passed to subsequent subworkflows. \u26a0\ufe0f The automatic database indexing is work in progress and not implemented yet! \u2935\ufe0f Status [x] proposed [ ] accepted [ ] deprecated [ ] superseded (via ADR#) Consequences Pro: properly labeled and single global Nextlow channel static mode skips entire reference selection procedure Con: mildly more code in the main workflow due to the --reference_selection switch","title":"003 INV referenceSelectionNextflowChannels"},{"location":"adr/003_INV_referenceSelectionNextflowChannels/#title","text":"Design decisions about the reference selection and how to load, organize, and pass reference sequences via Nextflow channels.","title":"Title"},{"location":"adr/003_INV_referenceSelectionNextflowChannels/#context","text":"The Influenza workflow currently has two modes of providing reference genome segments via --reference selection , static and kma . For downstream processes of the workflow, both modes must eventually create and pass a channel of one final FASTA file of genome segments. Problem. Each mode of the --reference_selection accepts a different input format: with static the workflow takes a single FASTA file (with one sequence per segment) and with kma the workflow takes a directory of multiple FASTA files (one file per segment containing one or more sequences) and their KMA index files, together called database . These input formats require a Nextflow channel design where, ideally, a minimal number of channels are passed downstream and no channels need to be joint, split or reordered as part of the main workflow.","title":"Context"},{"location":"adr/003_INV_referenceSelectionNextflowChannels/#decision","text":"We maintain a single global Nextflow channel ch_final_topRefs for the purpose of reference selection. The static mode simply passes a single FASTA file to ch_final_topRefs which is not subject to further selection steps. The kma mode uses the database to load its FASTA files and index files into two separate temporary channels. These two channels are passed to the reference selection subworkflow FASTA_REFERENCE_SELECTION_ALL . The reference selection subworkflow returns a single FASTA file of one sequence per segment. This file is then stored in the ch_final_topRefs channel and passed to subsequent subworkflows. \u26a0\ufe0f The automatic database indexing is work in progress and not implemented yet! \u2935\ufe0f","title":"Decision"},{"location":"adr/003_INV_referenceSelectionNextflowChannels/#status","text":"[x] proposed [ ] accepted [ ] deprecated [ ] superseded (via ADR#)","title":"Status"},{"location":"adr/003_INV_referenceSelectionNextflowChannels/#consequences","text":"Pro: properly labeled and single global Nextlow channel static mode skips entire reference selection procedure Con: mildly more code in the main workflow due to the --reference_selection switch","title":"Consequences"},{"location":"adr/004_INV_referencePreparation/","text":"Title Decision on how to handle IUPAC characters and N's in the reference sequence. Context The INV GR workflow contains a process in which a python script is executed, which replaces all IUPAC characters and N's with static, unambiguous characters (ACGT). Since this seems unintuitive and potentially could introduce differences in the results, we decided to assess the effects of these replacements. Removing this step entirely resulted in problems with our variant caller lofreq, which produced VCF files with byte errors in them. This led to crashes in subsequent processes. According to a comment in the original script, not only lofreq, but also bcftools consensus can't handle IUPAC characters. Next, we assessed whether replacing IUPAC characters with statically defined bases introduces a downstream bias. Therefore, we generated five distinct copies of the same reference genome where the IUPAC and 'N' characters were randomly replaced with unambiguous nucleotide characters. Each copy was used as a reference for genome reconstruction of three real data samples (5*3 experiments). We observed changes in the VCF files due to different interpretations of the IUPAC characters. We noticed that especially N's are problematic, since these positions don't appear in the VCF files and seem to be conserved in the consensus sequence. However, in the case that an 'N' is replaced by an unambiguous nucleotide character, the position is considered for the variant calling. Subsequently, if the unambiguous nucleotide character in the reference genome differs from the majority allele among the aligned reads it will be replaced during the consensus generation. After removing the option of replacing IUPAC characters with N's, we observed identical md5sums of the consensus sequences across all runs for all samples respectively. Decision We found that 'N's and IUPUC characters cause issues with internal software (lofreq). However, replacing those characters with unambiguous nucleotide characters showed no downstream effect on the generated consensus sequences. For the purpose of reproducibility, we decide to define static replacements of all IUPAC and 'N' characters into unambiguous nucleotide characters. Status [ ] proposed [x] accepted [ ] deprecated [ ] superseded (via ADR#) Consequences Pro: no randomness, good reproducibility both IUPAC and 'N' character positions in the reference genome are now considered for variant calling and consensus generation Con: seems unintuitive and error-prone at first an extremely high ratio of characters in the reference genome being replaced by the proposed method might causes alignment artifacts. However, within the scope of our assessment we observed this effect as minor/ not present.","title":"004 INV referencePreparation"},{"location":"adr/004_INV_referencePreparation/#title","text":"Decision on how to handle IUPAC characters and N's in the reference sequence.","title":"Title"},{"location":"adr/004_INV_referencePreparation/#context","text":"The INV GR workflow contains a process in which a python script is executed, which replaces all IUPAC characters and N's with static, unambiguous characters (ACGT). Since this seems unintuitive and potentially could introduce differences in the results, we decided to assess the effects of these replacements. Removing this step entirely resulted in problems with our variant caller lofreq, which produced VCF files with byte errors in them. This led to crashes in subsequent processes. According to a comment in the original script, not only lofreq, but also bcftools consensus can't handle IUPAC characters. Next, we assessed whether replacing IUPAC characters with statically defined bases introduces a downstream bias. Therefore, we generated five distinct copies of the same reference genome where the IUPAC and 'N' characters were randomly replaced with unambiguous nucleotide characters. Each copy was used as a reference for genome reconstruction of three real data samples (5*3 experiments). We observed changes in the VCF files due to different interpretations of the IUPAC characters. We noticed that especially N's are problematic, since these positions don't appear in the VCF files and seem to be conserved in the consensus sequence. However, in the case that an 'N' is replaced by an unambiguous nucleotide character, the position is considered for the variant calling. Subsequently, if the unambiguous nucleotide character in the reference genome differs from the majority allele among the aligned reads it will be replaced during the consensus generation. After removing the option of replacing IUPAC characters with N's, we observed identical md5sums of the consensus sequences across all runs for all samples respectively.","title":"Context"},{"location":"adr/004_INV_referencePreparation/#decision","text":"We found that 'N's and IUPUC characters cause issues with internal software (lofreq). However, replacing those characters with unambiguous nucleotide characters showed no downstream effect on the generated consensus sequences. For the purpose of reproducibility, we decide to define static replacements of all IUPAC and 'N' characters into unambiguous nucleotide characters.","title":"Decision"},{"location":"adr/004_INV_referencePreparation/#status","text":"[ ] proposed [x] accepted [ ] deprecated [ ] superseded (via ADR#)","title":"Status"},{"location":"adr/004_INV_referencePreparation/#consequences","text":"Pro: no randomness, good reproducibility both IUPAC and 'N' character positions in the reference genome are now considered for variant calling and consensus generation Con: seems unintuitive and error-prone at first an extremely high ratio of characters in the reference genome being replaced by the proposed method might causes alignment artifacts. However, within the scope of our assessment we observed this effect as minor/ not present.","title":"Consequences"},{"location":"adr/005_INV_filteringSamplesWithoutReads/","text":"Title Filtering function excluding samples without reads after Kraken 2 classification or taxonomic read extraction Context While running Omnifluss on routine runs, we observed errors that were caused by samples of bad quality (e.g. negative controls, samples with little INV content). These samples could lead to errors in KRAKENTOOLS_EXTRACTKRAKENREADS or KMA , which is the subsequent process when the automatic reference selection is enabled. To deal with this issue we implemented a filtering function that is once executed after KRAKEN2_KRAKEN2 and once after KRAKENTOOLS_EXTRACTKRAKENREADS in the FASTQ_TAXONOMIC_FILTERING_ALL subworkflow. For this function very specific decisions had to be made, which is the reason for this adr. The most intuitive way of implementing such a function is to account for single-end and paired-end data and simply check the byte-size of the file(s) (e.g. file(reads).size() ). However, this approach was not possible, because the read files are gzipped, which means that the file size can't be zero due to metadata that is stored in such files (even in empty ones). The alternative to this was to not base the decision on size, but on number of lines, which is equal to zero in empty files. Since there is no native and suitable way to access gzipped files, we decided to use the countFastq operator, which counts the number of records in a channel of FastQ files. This operator has the downside that it is relatively slow and would do a lot of unnecessary work in our case, since all the reads would be counted, although it would be sufficient to terminate after observing a single one. With this in mind we implemented a pre-filter that is based on size. Instead of counting the reads for every file, only files smaller than a certain threshold (500 at the time of writing) are passed for read counting. That way we can reduce the computational burden, while still be able to base the final decision on the number of reads. While the essence of the function is covered, we observed a special case, which needed to be accounted for. We observed that our stub tests lead to EOF errors in the filtering function. These errors were caused by the countFastq operator, when applying it on files with byte-size zero. These files could only occur in stub tests, because \"fake\" gzipped files are created there. These files have the same naming convention as gzipped files ( filename.gz ), but are simply generated with touch filename.gz , which leads to them having a byte-size of zero, although looking like gzipped files. The solution for this problem was to explicitly check if a file has a byte-size of zero and only if it has not, to allow it for the checks described previously. Decision We implemented a filtering function that is able to filter out empty FastQ files, using an approach with prefiltering based on the file size and the final decision based on number of lines. We made sure that edgecases (stub-test) are covered and verified the correctness of the function by successfully rerunning samples that caused the errors in the first place. Status [ ] proposed [x] accepted [ ] deprecated [ ] superseded (via ADR#) Consequences Pro: reliable filtering based on size and number of lines efficient approach Con: implementation not very intuitive without the information about the reasoning specific check needed only for stub-tests","title":"005 INV filteringSamplesWithoutReads"},{"location":"adr/005_INV_filteringSamplesWithoutReads/#title","text":"Filtering function excluding samples without reads after Kraken 2 classification or taxonomic read extraction","title":"Title"},{"location":"adr/005_INV_filteringSamplesWithoutReads/#context","text":"While running Omnifluss on routine runs, we observed errors that were caused by samples of bad quality (e.g. negative controls, samples with little INV content). These samples could lead to errors in KRAKENTOOLS_EXTRACTKRAKENREADS or KMA , which is the subsequent process when the automatic reference selection is enabled. To deal with this issue we implemented a filtering function that is once executed after KRAKEN2_KRAKEN2 and once after KRAKENTOOLS_EXTRACTKRAKENREADS in the FASTQ_TAXONOMIC_FILTERING_ALL subworkflow. For this function very specific decisions had to be made, which is the reason for this adr. The most intuitive way of implementing such a function is to account for single-end and paired-end data and simply check the byte-size of the file(s) (e.g. file(reads).size() ). However, this approach was not possible, because the read files are gzipped, which means that the file size can't be zero due to metadata that is stored in such files (even in empty ones). The alternative to this was to not base the decision on size, but on number of lines, which is equal to zero in empty files. Since there is no native and suitable way to access gzipped files, we decided to use the countFastq operator, which counts the number of records in a channel of FastQ files. This operator has the downside that it is relatively slow and would do a lot of unnecessary work in our case, since all the reads would be counted, although it would be sufficient to terminate after observing a single one. With this in mind we implemented a pre-filter that is based on size. Instead of counting the reads for every file, only files smaller than a certain threshold (500 at the time of writing) are passed for read counting. That way we can reduce the computational burden, while still be able to base the final decision on the number of reads. While the essence of the function is covered, we observed a special case, which needed to be accounted for. We observed that our stub tests lead to EOF errors in the filtering function. These errors were caused by the countFastq operator, when applying it on files with byte-size zero. These files could only occur in stub tests, because \"fake\" gzipped files are created there. These files have the same naming convention as gzipped files ( filename.gz ), but are simply generated with touch filename.gz , which leads to them having a byte-size of zero, although looking like gzipped files. The solution for this problem was to explicitly check if a file has a byte-size of zero and only if it has not, to allow it for the checks described previously.","title":"Context"},{"location":"adr/005_INV_filteringSamplesWithoutReads/#decision","text":"We implemented a filtering function that is able to filter out empty FastQ files, using an approach with prefiltering based on the file size and the final decision based on number of lines. We made sure that edgecases (stub-test) are covered and verified the correctness of the function by successfully rerunning samples that caused the errors in the first place.","title":"Decision"},{"location":"adr/005_INV_filteringSamplesWithoutReads/#status","text":"[ ] proposed [x] accepted [ ] deprecated [ ] superseded (via ADR#)","title":"Status"},{"location":"adr/005_INV_filteringSamplesWithoutReads/#consequences","text":"Pro: reliable filtering based on size and number of lines efficient approach Con: implementation not very intuitive without the information about the reasoning specific check needed only for stub-tests","title":"Consequences"},{"location":"pathogens/inv/","text":"Influenza Omnifluss can perform genome reconstruction of Influenza viruses using Illumina short-read NGS data. Usage Here, we begin the explanations of how to run omnifluss with basic examples and progress to more advanced setups. Omnifluss can be finetuned in many aspects such as runtime parameters , internal algorithms, deactivation of subroutines, optimisation to certain compute environments and usage of different databases. Basic run To begin with, a command for a basic run of omnifluss is nextflow run rki-mf1/omnifluss \\ -profile singularity \\ --input samplesheet.csv \\ --reference my_virus_reference.fasta \\ --kraken2_db /path/to/my/kraken2db/ \\ --outdir results Note: Mind the usage of different hyphen here! We use a single hyphen for Nextflow options and use a double hyphen for omnifluss specific parameters. This command launches a basic omnifluss run with tasks executed within singularity containers, sequence data defined in the samplesheet, a FASTA file containing a reference sequence, a Kraken2 database, and results stored in an output folder called results . See the Output chapter for the documentation of omnifluss' outputs. Reproducibility To ensures that a specific version of omnifluss is used when running the pipeline, you can specify a release tag. If you keep using the same release tag, you'll be running the same version of omnifluss, even if there have been changes to the code since that version. You can visit the releases page and find the latest pipeline version at the top of the website. Then, by running omnifluss with the Nextflow option -r (using one hyphen, eg. -r v0.2.1 ), you can switch to a particular version of omnifluss: nextflow run rki-mf1/omnifluss \\ -r v0.2.1 \\ -profile singularity \\ --input samplesheet.csv \\ --reference my_virus_reference.fasta \\ --kraken2_db /path/to/my/kraken2db/ \\ --outdir results The version of omnifluss used in a particular run is written to the Nextlow log file for reproducibility. Updating the pipeline When you run omnifluss as in the basic run example, Nextflow automatically pulls the pipeline code from the GitHub repository and stores a local copy (called cached version). When running the pipeline again, Nextflow uses this cached version by default if available - even if the pipeline code has been updated since the initial copying. You can manually update the cached version of the pipeline to the latest available version via nextflow pull rki-mf1/omnifluss Again, you can also add -r to update the cached version to a specific release via nextflow pull -r v0.2.0 rki-mf1/omnifluss Configs and profiles Omnifluss provides a plethora of parameters (use --help to inspect the manual page) to configure the workflow. To process Illumina paired-end short-read sequencing data of Influenza virus samples, we have prepared a configuration file with best-practise settings. This predefined configuration file can be provided to an omnifluss run via the -profile option: nextflow run rki-mf1/omnifluss \\ -profile singularity,INV_illumina \\ --input samplesheet.csv \\ --reference my_virus_reference.fasta \\ --kraken2_db /path/to/my/kraken2db/ \\ --outdir results Using the INV_illumina profile will overwrite multiple default parameters of omnifluss. Please inspect the configuration file for more details about the Influenza virus-specific parameters. Note that you can still provide omnifluss parameters on the command line in addition to profiles. The pipeline parameter precedence in Nextflow prioritizes command line parameters over parameters specified in a configuration file. See -params-file for more details on custom configuration files. Parameters --input The samples to be analysed are provided to omnifluss via a sample sheet (.csv) using the --input parameter. It specifies the raw read sequence data files (.fastq) used by omnifluss. For instance: sample,fastq_1,fastq_2 INV_ILL_NB1,/path/to/experiment_NB1_R1.fastq.gz,/path/to/experiment_NB1_R2.fastq.gz INV_ILL_NB2,/path/to/experiment_NB2_R1.fastq.gz,/path/to/experiment_NB2_R2.fastq.gz INV_ILL_NB3,/path/to/experiment_NB3_R1.fastq.gz,/path/to/experiment_NB3_R2.fastq.gz which refers to the structured information sample fastq_1 fastq_2 INV_ILL_NB1 /path/to/experiment_NB1_R1.fastq.gz /path/to/experiment_NB1_R2.fastq.gz INV_ILL_NB2 /path/to/experiment_NB2_R1.fastq.gz /path/to/experiment_NB2_R2.fastq.gz INV_ILL_NB3 /path/to/experiment_NB3_R1.fastq.gz /path/to/experiment_NB3_R2.fastq.gz The argument parser will automatically detect the sample and paired-end information provided by the sample sheet. The sample sheet requires a three-column entry per sample which has to match the definition below. Column Description sample Custom sample name. This entry might be identical for multiple sequencing libraries/runs from the same sample. Spaces in sample names are automatically converted to underscores ( _ ). fastq_1 Full path to FastQ file for Illumina short reads 1. File has to be gzipped and have the extension \".fastq.gz\" or \".fq.gz\". fastq_2 Full path to FastQ file for Illumina short reads 2. File has to be gzipped and have the extension \".fastq.gz\" or \".fq.gz\". --reference File containing one or multiple reference sequence. Parameter value is a FASTA file. For the influenza virus, the FASTA file typically contains eight reference sequences, i.e. one per segment. However, another collection might suit your research question. All reads from the --input FASTQ files are mapped against the sequences in --reference and these mappings will ultimately be used for a reference-guided assembly. Exactly one of the two parameters --reference and --reference_selection_db has to be provided to omnifluss when process Influenza virus data. These two parameters provide the references for the consensus sequence reconstruction. Depending on the choice of the first reference parameter, the --reference_selection parameter has to be set accordingly. The parameter combination --reference_selection kma --reference_selection_db <path> (default when using the INV_illumina profile) activates a selection process for the best fitting reference from the given reference database at <path> . Please see --reference_selection_db for more details on the reference database. The parameter combination --reference_selection static --reference <fasta> takes strictly the sequences in <fasta> as reference sequences for the genome reconstruction. --reference_selection Reference selection mode. Choice of \" kma \" and \" static \". Please see --reference for more details. --reference_selection_db Database for automatic reference selection. Parameter value is a path to a reference database. The reference database has to comply with the following format: for each of the genome segments of the Influenza virus (HA, NA, MP, NP, NS, PA, PB1, PB2), the reference database can contain up to one FASTA file containing one or multiple reference sequences. Further, the FASTA file names have to begin with <segment_name>. , i.e. a valid database could looks like /path/ \u251c\u2500\u2500 HA.segment.fasta \u251c\u2500\u2500 MP.segment.fasta \u251c\u2500\u2500 NA.segment.fasta \u251c\u2500\u2500 NP.segment.fasta \u251c\u2500\u2500 NS.segment.fasta \u251c\u2500\u2500 PA.segment.fasta \u251c\u2500\u2500 PB1.segment.fasta \u2514\u2500\u2500 PB2.segment.fasta Please see --reference for more details. --kraken2_db \\<WIP> --fastp_adapter_fasta You can especify a plain FASTA file for adapter clipping. E.g. for Illumina Nextera Transposase adapter >Illumina Nextera Transposase adapter fwd TCGTCGGCAGCGTCAGATGTGTATAAGAGACAG >Illumina Nextera Transposase adapter rev GTCTCGTGGGCTCGGAGATGTGTATAAGAGACAG --help Various parameters can be finetuned throughout the workflow. You can find the full list of parameters via nextflow run rki-mf1/omnifluss -r <release-tag> --help . Note: The documentation of pipeline parameters is generated automatically from the pipeline schema. Options are part of Nextflow and use a single hyphen (pipeline parameters use a double-hyphen). -params-file Each parameter of omnifluss can also be written into a configuration file (in JSON or YAML format) and provided to omnifluss via -params-file <file> . For instance, the basic run case of omnifluss can be shortened and specified with a configuration file: nextflow run rki-mf1/omnifluss \\ -profile singularity \\ -params-file params.yaml with the corresponding YAML file params.yaml : input: 'samplesheet.csv' reference: 'my_virus_reference.fasta' kraken2_db: '/path/to/my/kraken2db/' outdir: 'results' Warning: Do not use the -c <file> to specify pipeline parameters as this will result in errors! Custom config files specified in -c must only be used for tuning process resource specifications or module arguments (args). -resume Specify -resume when restarting a pipeline. Nextflow reuses all cached intermediate results from pipeline steps start are not affected by changes between the runs. For more info about this parameter, see this blog post . You can also supply a run name to resume a specific run: -resume [run-name] . Use the nextflow log command to show previous run names. --outdir \\<WIP> Output After a successful run, the pipeline creates the following files and folders in your working directory: work # Directory containing the Nextflow working files <outdir> # Results in specified location (defined with --outdir) .nextflow_log # Log file from Nextflow \\<WIP>","title":"Influenza virus"},{"location":"pathogens/inv/#influenza","text":"Omnifluss can perform genome reconstruction of Influenza viruses using Illumina short-read NGS data.","title":"Influenza"},{"location":"pathogens/inv/#usage","text":"Here, we begin the explanations of how to run omnifluss with basic examples and progress to more advanced setups. Omnifluss can be finetuned in many aspects such as runtime parameters , internal algorithms, deactivation of subroutines, optimisation to certain compute environments and usage of different databases.","title":"Usage"},{"location":"pathogens/inv/#basic-run","text":"To begin with, a command for a basic run of omnifluss is nextflow run rki-mf1/omnifluss \\ -profile singularity \\ --input samplesheet.csv \\ --reference my_virus_reference.fasta \\ --kraken2_db /path/to/my/kraken2db/ \\ --outdir results Note: Mind the usage of different hyphen here! We use a single hyphen for Nextflow options and use a double hyphen for omnifluss specific parameters. This command launches a basic omnifluss run with tasks executed within singularity containers, sequence data defined in the samplesheet, a FASTA file containing a reference sequence, a Kraken2 database, and results stored in an output folder called results . See the Output chapter for the documentation of omnifluss' outputs.","title":"Basic run"},{"location":"pathogens/inv/#reproducibility","text":"To ensures that a specific version of omnifluss is used when running the pipeline, you can specify a release tag. If you keep using the same release tag, you'll be running the same version of omnifluss, even if there have been changes to the code since that version. You can visit the releases page and find the latest pipeline version at the top of the website. Then, by running omnifluss with the Nextflow option -r (using one hyphen, eg. -r v0.2.1 ), you can switch to a particular version of omnifluss: nextflow run rki-mf1/omnifluss \\ -r v0.2.1 \\ -profile singularity \\ --input samplesheet.csv \\ --reference my_virus_reference.fasta \\ --kraken2_db /path/to/my/kraken2db/ \\ --outdir results The version of omnifluss used in a particular run is written to the Nextlow log file for reproducibility.","title":"Reproducibility"},{"location":"pathogens/inv/#updating-the-pipeline","text":"When you run omnifluss as in the basic run example, Nextflow automatically pulls the pipeline code from the GitHub repository and stores a local copy (called cached version). When running the pipeline again, Nextflow uses this cached version by default if available - even if the pipeline code has been updated since the initial copying. You can manually update the cached version of the pipeline to the latest available version via nextflow pull rki-mf1/omnifluss Again, you can also add -r to update the cached version to a specific release via nextflow pull -r v0.2.0 rki-mf1/omnifluss","title":"Updating the pipeline"},{"location":"pathogens/inv/#configs-and-profiles","text":"Omnifluss provides a plethora of parameters (use --help to inspect the manual page) to configure the workflow. To process Illumina paired-end short-read sequencing data of Influenza virus samples, we have prepared a configuration file with best-practise settings. This predefined configuration file can be provided to an omnifluss run via the -profile option: nextflow run rki-mf1/omnifluss \\ -profile singularity,INV_illumina \\ --input samplesheet.csv \\ --reference my_virus_reference.fasta \\ --kraken2_db /path/to/my/kraken2db/ \\ --outdir results Using the INV_illumina profile will overwrite multiple default parameters of omnifluss. Please inspect the configuration file for more details about the Influenza virus-specific parameters. Note that you can still provide omnifluss parameters on the command line in addition to profiles. The pipeline parameter precedence in Nextflow prioritizes command line parameters over parameters specified in a configuration file. See -params-file for more details on custom configuration files.","title":"Configs and profiles"},{"location":"pathogens/inv/#parameters","text":"","title":"Parameters"},{"location":"pathogens/inv/#-input","text":"The samples to be analysed are provided to omnifluss via a sample sheet (.csv) using the --input parameter. It specifies the raw read sequence data files (.fastq) used by omnifluss. For instance: sample,fastq_1,fastq_2 INV_ILL_NB1,/path/to/experiment_NB1_R1.fastq.gz,/path/to/experiment_NB1_R2.fastq.gz INV_ILL_NB2,/path/to/experiment_NB2_R1.fastq.gz,/path/to/experiment_NB2_R2.fastq.gz INV_ILL_NB3,/path/to/experiment_NB3_R1.fastq.gz,/path/to/experiment_NB3_R2.fastq.gz which refers to the structured information sample fastq_1 fastq_2 INV_ILL_NB1 /path/to/experiment_NB1_R1.fastq.gz /path/to/experiment_NB1_R2.fastq.gz INV_ILL_NB2 /path/to/experiment_NB2_R1.fastq.gz /path/to/experiment_NB2_R2.fastq.gz INV_ILL_NB3 /path/to/experiment_NB3_R1.fastq.gz /path/to/experiment_NB3_R2.fastq.gz The argument parser will automatically detect the sample and paired-end information provided by the sample sheet. The sample sheet requires a three-column entry per sample which has to match the definition below. Column Description sample Custom sample name. This entry might be identical for multiple sequencing libraries/runs from the same sample. Spaces in sample names are automatically converted to underscores ( _ ). fastq_1 Full path to FastQ file for Illumina short reads 1. File has to be gzipped and have the extension \".fastq.gz\" or \".fq.gz\". fastq_2 Full path to FastQ file for Illumina short reads 2. File has to be gzipped and have the extension \".fastq.gz\" or \".fq.gz\".","title":"--input"},{"location":"pathogens/inv/#-reference","text":"File containing one or multiple reference sequence. Parameter value is a FASTA file. For the influenza virus, the FASTA file typically contains eight reference sequences, i.e. one per segment. However, another collection might suit your research question. All reads from the --input FASTQ files are mapped against the sequences in --reference and these mappings will ultimately be used for a reference-guided assembly. Exactly one of the two parameters --reference and --reference_selection_db has to be provided to omnifluss when process Influenza virus data. These two parameters provide the references for the consensus sequence reconstruction. Depending on the choice of the first reference parameter, the --reference_selection parameter has to be set accordingly. The parameter combination --reference_selection kma --reference_selection_db <path> (default when using the INV_illumina profile) activates a selection process for the best fitting reference from the given reference database at <path> . Please see --reference_selection_db for more details on the reference database. The parameter combination --reference_selection static --reference <fasta> takes strictly the sequences in <fasta> as reference sequences for the genome reconstruction.","title":"--reference"},{"location":"pathogens/inv/#-reference_selection","text":"Reference selection mode. Choice of \" kma \" and \" static \". Please see --reference for more details.","title":"--reference_selection"},{"location":"pathogens/inv/#-reference_selection_db","text":"Database for automatic reference selection. Parameter value is a path to a reference database. The reference database has to comply with the following format: for each of the genome segments of the Influenza virus (HA, NA, MP, NP, NS, PA, PB1, PB2), the reference database can contain up to one FASTA file containing one or multiple reference sequences. Further, the FASTA file names have to begin with <segment_name>. , i.e. a valid database could looks like /path/ \u251c\u2500\u2500 HA.segment.fasta \u251c\u2500\u2500 MP.segment.fasta \u251c\u2500\u2500 NA.segment.fasta \u251c\u2500\u2500 NP.segment.fasta \u251c\u2500\u2500 NS.segment.fasta \u251c\u2500\u2500 PA.segment.fasta \u251c\u2500\u2500 PB1.segment.fasta \u2514\u2500\u2500 PB2.segment.fasta Please see --reference for more details.","title":"--reference_selection_db"},{"location":"pathogens/inv/#-kraken2_db","text":"\\<WIP>","title":"--kraken2_db"},{"location":"pathogens/inv/#-fastp_adapter_fasta","text":"You can especify a plain FASTA file for adapter clipping. E.g. for Illumina Nextera Transposase adapter >Illumina Nextera Transposase adapter fwd TCGTCGGCAGCGTCAGATGTGTATAAGAGACAG >Illumina Nextera Transposase adapter rev GTCTCGTGGGCTCGGAGATGTGTATAAGAGACAG","title":"--fastp_adapter_fasta"},{"location":"pathogens/inv/#-help","text":"Various parameters can be finetuned throughout the workflow. You can find the full list of parameters via nextflow run rki-mf1/omnifluss -r <release-tag> --help . Note: The documentation of pipeline parameters is generated automatically from the pipeline schema. Options are part of Nextflow and use a single hyphen (pipeline parameters use a double-hyphen).","title":"--help"},{"location":"pathogens/inv/#-params-file","text":"Each parameter of omnifluss can also be written into a configuration file (in JSON or YAML format) and provided to omnifluss via -params-file <file> . For instance, the basic run case of omnifluss can be shortened and specified with a configuration file: nextflow run rki-mf1/omnifluss \\ -profile singularity \\ -params-file params.yaml with the corresponding YAML file params.yaml : input: 'samplesheet.csv' reference: 'my_virus_reference.fasta' kraken2_db: '/path/to/my/kraken2db/' outdir: 'results' Warning: Do not use the -c <file> to specify pipeline parameters as this will result in errors! Custom config files specified in -c must only be used for tuning process resource specifications or module arguments (args).","title":"-params-file"},{"location":"pathogens/inv/#-resume","text":"Specify -resume when restarting a pipeline. Nextflow reuses all cached intermediate results from pipeline steps start are not affected by changes between the runs. For more info about this parameter, see this blog post . You can also supply a run name to resume a specific run: -resume [run-name] . Use the nextflow log command to show previous run names.","title":"-resume"},{"location":"pathogens/inv/#-outdir","text":"\\<WIP>","title":"--outdir"},{"location":"pathogens/inv/#output","text":"After a successful run, the pipeline creates the following files and folders in your working directory: work # Directory containing the Nextflow working files <outdir> # Results in specified location (defined with --outdir) .nextflow_log # Log file from Nextflow \\<WIP>","title":"Output"}]}